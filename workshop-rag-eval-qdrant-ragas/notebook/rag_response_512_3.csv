question,answer,contexts,ground_truth
What is vaccum optimizer ?," The vacuum optimizer is a feature that helps to optimize the performance of a database by removing unnecessary data and reorganizing the remaining data. This can improve the speed and efficiency of database operations. This feature is available in the OptimizersConfigDiff class, which can be configured to set the default number of segments to 2. This information can be found in the documentation under the ""Optimization with Web Workers"" section of the ""Web UI GSOC"" article.","['document:optimizersConfig: new OptimizersConfigDiff { DefaultSegmentNumber = 2 }\n\n);\n\n```,source:documentation/guides/optimize.md'
 'document:optimizersConfig: new OptimizersConfigDiff { DefaultSegmentNumber = 2 }\n\n);\n\n```,source:documentation/guides/optimize.md'
 'document:#### Optimization with Web Workers,source:articles/web-ui-gsoc.md']","The Vacuum Optimizer is a feature in the Qdrant database designed to manage and improve system performance by removing obsolete data. In Qdrant, when records are deleted, they are not immediately removed from the database. Instead, they are marked as deleted and subsequently ignored in future queries. This approach helps minimize disk access but results in accumulated deleted records that can occupy valuable memory and degrade performance over time.
The Vacuum Optimizer addresses this issue by systematically clearing out these marked-as-deleted records once they reach a certain threshold. This threshold is configurable and includes conditions such as the minimum fraction of deleted vectors in a segment and the minimum number of vectors present in a segment. "
Tell me about ‘always_ram’ parameter?," The `always_ram` parameter is used to determine whether quantized vectors should be kept in RAM or not. By default, quantized vectors are loaded in the same way as the original vectors. However, in some setups, it may be beneficial to keep quantized vectors in RAM to speed up the search process. This can be achieved by setting `always_ram` to `true`. For more information on binary quantization and its parameters, please refer to the documentation on [Quantization](documentation/guides/quantization.md).","['document:""compression"": ""x32"",\n\n                    ""always_ram"": true\n\n                }\n\n            },\n\n            ""on_disk"": true\n\n        }\n\n    },\n\n    ""hnsw_config"": {\n\n        ""ef_construct"": 123\n\n    },\n\n    ""quantization_config"": {\n\n        ""scalar"": {\n\n            ""type"": ""int8"",\n\n            ""quantile"": 0.8,\n\n            ""always_ram"": false\n\n        }\n\n    }\n\n}\n\n```\n\n\n\n```bash\n\ncurl -X PATCH http://localhost:6333/collections/test_collection1 \\,source:documentation/concepts/collections.md'
 'document:""compression"": ""x32"",\n\n                    ""always_ram"": true\n\n                }\n\n            },\n\n            ""on_disk"": true\n\n        }\n\n    },\n\n    ""hnsw_config"": {\n\n        ""ef_construct"": 123\n\n    },\n\n    ""quantization_config"": {\n\n        ""scalar"": {\n\n            ""type"": ""int8"",\n\n            ""quantile"": 0.8,\n\n            ""always_ram"": false\n\n        }\n\n    }\n\n}\n\n```\n\n\n\n```bash\n\ncurl -X PATCH http://localhost:6333/collections/test_collection1 \\,source:documentation/concepts/collections.md'
 'document:It might be worth tuning this parameter if you experience a significant decrease in search quality.\n\n\n\n`always_ram` - whether to keep quantized vectors always cached in RAM or not. By default, quantized vectors are loaded in the same way as the original vectors.\n\nHowever, in some setups you might want to keep quantized vectors in RAM to speed up the search process.\n\n\n\nIn this case, you can set `always_ram` to `true` to store quantized vectors in RAM.\n\n\n\n### Setting up Binary Quantization,source:documentation/guides/quantization.md']","In the context of vector quantization in Qdrant, the 'always_ram' parameter determines whether quantized vectors should be kept always cached in RAM or not. By default, quantized vectors are loaded in the same manner as the original vectors. Setting 'always_ram' to true ensures that the quantized vectors are consistently cached in RAM, providing faster access times."
What is difference between scalar and product quantization?," The main difference between scalar and product quantization is the tradeoff between speed and accuracy. Scalar quantization is faster but has a loss of accuracy, while product quantization is slower but more accurate. This is due to the fact that product quantization distance calculations are not SIMD-friendly, making it slower than scalar quantization. Additionally, product quantization is recommended for use with high-dimensional vectors, while scalar quantization is suitable for lower-dimensional vectors. For more information on how to choose the right quantization method for your use case, please refer to the ""Quantization Tips"" section in the documentation/guides/quantization.md file.","['document:But there are some tradeoffs. Product quantization distance calculations are not SIMD-friendly, so it is slower than scalar quantization.\n\nAlso, product quantization has a loss of accuracy, so it is recommended to use it only for high-dimensional vectors.\n\n\n\nPlease refer to the [Quantization Tips](#quantization-tips) section for more information on how to optimize the quantization parameters for your use case.\n\n\n\n## How to choose the right quantization method,source:documentation/guides/quantization.md'
 'document:But there are some tradeoffs. Product quantization distance calculations are not SIMD-friendly, so it is slower than scalar quantization.\n\nAlso, product quantization has a loss of accuracy, so it is recommended to use it only for high-dimensional vectors.\n\n\n\nPlease refer to the [Quantization Tips](#quantization-tips) section for more information on how to optimize the quantization parameters for your use case.\n\n\n\n## How to choose the right quantization method,source:documentation/guides/quantization.md'
 'document:The main drawback of scalar quantization is the loss of accuracy. The `float32 -> uint8` conversion introduces an error that can lead to a slight decrease in search quality.\n\nHowever, this error is usually negligible, and tends to be less significant for high-dimensional vectors.\n\nIn our experiments, we found that the error introduced by scalar quantization is usually less than 1%. \n\n\n\nHowever, this value depends on the data and the quantization parameters.,source:documentation/guides/quantization.md']","While both methods aim to reduce the memory footprint and potentially speed up operations, scalar quantization offers faster processing with SIMD-friendly operations and minimal accuracy loss, making it suitable for scenarios where speed is critical. Product quantization achieves higher compression rates and is better suited for handling very high-dimensional vectors where memory space is more of a concern than computation speed."
What is ‘best_score’ strategy?," The 'best_score' strategy is a method used in Qdrant to measure the performance of a candidate against every example. It selects the best positive and best negative scores and uses a step formula to determine the final score. This strategy is impacted by the amount of examples and its performance is linearly affected by it. This information can be found in the documentation under the 'Explore' section, specifically in the 'best_score' strategy subsection.","['document:#   [ScoredPoint(id=3, version=0, score=0.09, \n\n#                payload=None, vector=[0.0, 0.0, 0.0, 0.1]),\n\n#    ScoredPoint(id=1, version=0, score=0.10049876, \n\n#                payload=None, vector=[0.0, 0.1, 0.0, 0.0])]\n\n# ]\n\n\n\n```,source:blog/batch-vector-search-with-qdrant.md'
 'document:#   [ScoredPoint(id=3, version=0, score=0.09, \n\n#                payload=None, vector=[0.0, 0.0, 0.0, 0.1]),\n\n#    ScoredPoint(id=1, version=0, score=0.10049876, \n\n#                payload=None, vector=[0.0, 0.1, 0.0, 0.0])]\n\n# ]\n\n\n\n```,source:blog/batch-vector-search-with-qdrant.md'
 'document:The way it works is that each candidate is measured against every example, then we select the best positive and best negative scores. The final score is chosen with this step formula:\n\n\n\n```rust\n\nlet score = if best_positive_score > best_negative_score {\n\n    best_positive_score;\n\n} else {\n\n    -(best_negative_score * best_negative_score);\n\n};\n\n```\n\n\n\n<aside role=""alert"">\n\nThe performance of <code>best_score</code> strategy will be linearly impacted by the amount of examples.\n\n</aside>,source:documentation/concepts/explore.md']","The `best_score` strategy is based on the idea of finding similar vectors by identifying those that are closer to a positive example while avoiding those that are closer to a negative one. This strategy measures each candidate against every example and selects the best positive and best negative scores. The final score is determined using a specific formula: if the best positive score is greater than the best negative score, the final score is set as the best positive score. Otherwise, the final score is calculated as the negative of the square of the best negative score. It is important to note that the performance of the `best_score` strategy is linearly impacted by the number of examples provided."
How does oversampling helps?," Oversampling helps to equalize the representation of classes in the training dataset, allowing for more fair and accurate modeling of real-world scenarios. This information can be found in the article ""Binary Quantization"" under the section ""Oversampling"" on page 2.","['document:oversampling helps equalize the representation of classes in the training dataset, thus enabling more fair and accurate modeling of real-world scenarios.,source:articles/binary-quantization-openai.md'
 'document:oversampling helps equalize the representation of classes in the training dataset, thus enabling more fair and accurate modeling of real-world scenarios.,source:articles/binary-quantization-openai.md'
 'document:These two parameters are how you are going to balance speed versus accuracy. The larger the size of your oversample, the more items you need to read from disk and the more elements you have to search with the relatively slower full vector index. On the other hand, doing this will produce more accurate results.,source:articles/binary-quantization.md']","Defines how many extra vectors should be pre-selected using quantized index, and then re-scored using original vectors. For example, if oversampling is 2.4 and limit is 100, then 240 vectors will be pre-selected using quantized index, and then top-100 will be returned after re-scoring. Oversampling is useful if you want to tune the tradeoff between search speed and search quality in the query time."
What is the purpose of ‘CreatePayloadIndexAsync’?," The 'CreatePayloadIndexAsync' function is used to create a new payload index for a specific collection in Qdrant. This allows for efficient indexing and searching of data within the collection. The function takes in parameters such as the collection name, group ID, and payload schema type to customize the index according to the user's needs. For more information on creating payload indexes, please refer to the 'Create Payload Index' section in the 'Multiple Partitions' guide in the Qdrant documentation (documentation/guides/multiple-partitions.md).","['document:```java\n\nimport io.qdrant.client.QdrantClient;\n\nimport io.qdrant.client.QdrantGrpcClient;\n\nimport io.qdrant.client.grpc.Collections.PayloadSchemaType;\n\n\n\nQdrantClient client =\n\n    new QdrantClient(QdrantGrpcClient.newBuilder(""localhost"", 6334, false).build());\n\n\n\nclient\n\n    .createPayloadIndexAsync(\n\n        ""{collection_name}"", ""group_id"", PayloadSchsemaType.Keyword, null, null, null, null)\n\n    .get();\n\n```\n\n\n\n```csharp\n\nusing Qdrant.Client;\n\n\n\nvar client = new QdrantClient(""localhost"", 6334);,source:documentation/guides/multiple-partitions.md'
 'document:```java\n\nimport io.qdrant.client.QdrantClient;\n\nimport io.qdrant.client.QdrantGrpcClient;\n\nimport io.qdrant.client.grpc.Collections.PayloadSchemaType;\n\n\n\nQdrantClient client =\n\n    new QdrantClient(QdrantGrpcClient.newBuilder(""localhost"", 6334, false).build());\n\n\n\nclient\n\n    .createPayloadIndexAsync(\n\n        ""{collection_name}"", ""group_id"", PayloadSchsemaType.Keyword, null, null, null, null)\n\n    .get();\n\n```\n\n\n\n```csharp\n\nusing Qdrant.Client;\n\n\n\nvar client = new QdrantClient(""localhost"", 6334);,source:documentation/guides/multiple-partitions.md'
 'document:client.createPayloadIndex(""{collection_name}"", {\n\n  field_name: ""name_of_the_field_to_index"",\n\n  field_schema: {\n\n    type: ""text"",\n\n    tokenizer: ""word"",\n\n    min_token_len: 2,\n\n    max_token_len: 15,\n\n    lowercase: true,\n\n  },\n\n});\n\n```\n\n\n\n```rust\n\nuse qdrant_client::{\n\n    client::QdrantClient,\n\n    qdrant::{\n\n        payload_index_params::IndexParams, FieldType, PayloadIndexParams, TextIndexParams,\n\n        TokenizerType,\n\n    },\n\n};,source:documentation/concepts/indexing.md']",CreatePayloadIndexAsync is a method in the Qdrant library that enables the creation of a payload index in Qdrant. A payload index is a data structure designed to store supplemental information about the data stored in Qdrant. This method requires a Qdrant instance and a payload index name as input parameters.
What is the purpose of ef_construct in HNSW ?," The ef_construct parameter in HNSW (Hierarchical Navigable Small World) is used to control the trade-off between the index build time and the index quality. It specifies the number of neighbors that are considered during the construction of the index. A higher value of ef_construct results in a better quality index but also increases the build time. This parameter can be set in the VectorParamsDiff struct when creating a collection. For more information, please refer to the 'HNSW Configuration' section in the 'Optimizing Index Performance' guide in the documentation.","['document:(""my_vector"".into()),\n\n                        VectorParamsDiff {\n\n                            hnsw_config: Some(HnswConfigDiff {\n\n                                m: Some(32),\n\n                                ef_construct: Some(123),\n\n                                ..Default::default()\n\n                            }),\n\n                            ..Default::default()\n\n                        },\n\n                    )]),\n\n                },\n\n            )),\n\n        }),,source:documentation/concepts/collections.md'
 'document:(""my_vector"".into()),\n\n                        VectorParamsDiff {\n\n                            hnsw_config: Some(HnswConfigDiff {\n\n                                m: Some(32),\n\n                                ef_construct: Some(123),\n\n                                ..Default::default()\n\n                            }),\n\n                            ..Default::default()\n\n                        },\n\n                    )]),\n\n                },\n\n            )),\n\n        }),,source:documentation/concepts/collections.md'
 'document:hnsw_ef: Some(128),\n\n            exact: Some(false),\n\n            ..Default::default()\n\n        }),\n\n        limit: 3,\n\n        ..Default::default()\n\n    })\n\n    .await?;\n\n```\n\n\n\n```java\n\nimport java.util.List;\n\n\n\nimport io.qdrant.client.QdrantClient;\n\nimport io.qdrant.client.QdrantGrpcClient;\n\nimport io.qdrant.client.grpc.Points.SearchParams;\n\nimport io.qdrant.client.grpc.Points.SearchPoints;\n\n\n\nQdrantClient client =,source:documentation/guides/optimize.md']","In HNSW algorithm the ef_construct parameter is the number of neighbours to consider during the index building. The larger the value, the higher the precision, but the longer the indexing time. The default values of this parameters 100"
How do you use ‘ordering’ parameter?," The 'ordering' parameter is used to specify the order in which the points will be returned in the response. It can be set to either 'strong' or 'weak' depending on the desired order. This parameter is included in the PUT request for adding points to a collection, and can be found in the 'batch' object within the request body. For more information on adding points to a collection, please refer to the 'distributed_deployment.md' guide in the 'documentation/guides' directory.","['document:```http\n\nPUT /collections/{collection_name}/points?ordering=strong\n\n{\n\n    ""batch"": {\n\n        ""ids"": [1, 2, 3],\n\n        ""payloads"": [\n\n            {""color"": ""red""},\n\n            {""color"": ""green""},\n\n            {""color"": ""blue""}\n\n        ],\n\n        ""vectors"": [\n\n            [0.9, 0.1, 0.1],\n\n            [0.1, 0.9, 0.1],\n\n            [0.1, 0.1, 0.9]\n\n        ]\n\n    }\n\n}\n\n```\n\n\n\n```python\n\nclient.upsert(\n\n    collection_name=""{collection_name}"",\n\n    points=models.Batch(\n\n        ids=[1, 2, 3],,source:documentation/guides/distributed_deployment.md'
 'document:```http\n\nPUT /collections/{collection_name}/points?ordering=strong\n\n{\n\n    ""batch"": {\n\n        ""ids"": [1, 2, 3],\n\n        ""payloads"": [\n\n            {""color"": ""red""},\n\n            {""color"": ""green""},\n\n            {""color"": ""blue""}\n\n        ],\n\n        ""vectors"": [\n\n            [0.9, 0.1, 0.1],\n\n            [0.1, 0.9, 0.1],\n\n            [0.1, 0.1, 0.9]\n\n        ]\n\n    }\n\n}\n\n```\n\n\n\n```python\n\nclient.upsert(\n\n    collection_name=""{collection_name}"",\n\n    points=models.Batch(\n\n        ids=[1, 2, 3],,source:documentation/guides/distributed_deployment.md'
 'document:limit: 10,\n\n        ..Default::default()\n\n    })\n\n    .await?;\n\n```\n\n\n\n```java\n\nimport java.util.List;\n\n\n\nimport static io.qdrant.client.PointIdFactory.id;\n\n\n\nimport io.qdrant.client.grpc.Points.RecommendPoints;\n\n\n\nclient\n\n    .recommendAsync(\n\n        RecommendPoints.newBuilder()\n\n            .setCollectionName(""{collection_name}"")\n\n            .addAllPositive(List.of(id(100), id(231)))\n\n            .addAllNegative(List.of(id(718)))\n\n            .setUsing(""image"")\n\n            .setLimit(10),source:documentation/concepts/explore.md']","Write ordering can be specified for any write request to serialize it through a single “leader” node, which ensures that all write operations (issued with the same ordering) are performed and observed sequentially. It is of 3 types weak , medium and strong and is used in python with additional param ordering=models.WriteOrdering.STRONG to upsert request."
What is significance of ‘on_disk_payload’ setting?," The 'on_disk_payload' setting in the collection parameters determines where the payload data will be stored. If set to 'true', the payload will only be stored on disk, which can be useful for limiting RAM usage when dealing with large payloads. This information can be found in the 'Collections' section of the documentation, specifically in the 'Default parameters for the optional collection parameters' subsection.","['document:* `on_disk_payload` - defines where to store payload data. If `true` - payload will be stored on disk only. Might be useful for limiting the RAM usage in case of large payload.\n\n* `quantization_config` - see [quantization](../../guides/quantization/#setting-up-quantization-in-qdrant) for details.\n\n\n\nDefault parameters for the optional collection parameters are defined in [configuration file](https://github.com/qdrant/qdrant/blob/master/config/config.yaml).,source:documentation/concepts/collections.md'
 'document:* `on_disk_payload` - defines where to store payload data. If `true` - payload will be stored on disk only. Might be useful for limiting the RAM usage in case of large payload.\n\n* `quantization_config` - see [quantization](../../guides/quantization/#setting-up-quantization-in-qdrant) for details.\n\n\n\nDefault parameters for the optional collection parameters are defined in [configuration file](https://github.com/qdrant/qdrant/blob/master/config/config.yaml).,source:documentation/concepts/collections.md'
 'document:""vectors"": {\n\n                    ""size"": 384,\n\n                    ""distance"": ""Cosine""\n\n                },\n\n                ""shard_number"": 1,\n\n                ""replication_factor"": 1,\n\n                ""write_consistency_factor"": 1,\n\n                ""on_disk_payload"": false\n\n            },\n\n            ""hnsw_config"": {\n\n                ""m"": 16,\n\n                ""ef_construct"": 100,\n\n                ""full_scan_threshold"": 10000,\n\n                ""max_indexing_threads"": 0\n\n            },,source:documentation/concepts/collections.md']","The `on_disk_payload` setting in the storage configuration determines whether a point's payload will be stored in memory or read from disk every time it is requested. When set to `true`, the point's payload will not be stored in memory, saving RAM but slightly increasing the response time as the data needs to be retrieved from disk. It is important to note that payload values involved in filtering and indexed values will still remain in RAM for efficient access. This setting allows for a balance between RAM usage and response time in handling data storage and retrieval processes."
What is the impact of ‘write_consistency_factor’ ?," The `write_consistency_factor` determines the number of replicas that must acknowledge a write operation before responding to the client. This value can be configured at the collection's creation time and is set to one by default. Increasing this value will make write operations more tolerant to network partitions in the cluster, but will also require a higher number of replicas to be active in order to perform write operations. This information can be found in the documentation under the 'Write consistency factor' section of the 'Distributed Deployment' guide.","['document:### Write consistency factor\n\n\n\nThe `write_consistency_factor` represents the number of replicas that must acknowledge a write operation before responding to the client. It is set to one by default.\n\nIt can be configured at the collection\'s creation time.\n\n\n\n```http\n\nPUT /collections/{collection_name}\n\n{\n\n    ""vectors"": {\n\n        ""size"": 300,\n\n        ""distance"": ""Cosine""\n\n    },\n\n    ""shard_number"": 6,\n\n    ""replication_factor"": 2,\n\n    ""write_consistency_factor"": 2,\n\n}\n\n```\n\n\n\n```python,source:documentation/guides/distributed_deployment.md'
 'document:### Write consistency factor\n\n\n\nThe `write_consistency_factor` represents the number of replicas that must acknowledge a write operation before responding to the client. It is set to one by default.\n\nIt can be configured at the collection\'s creation time.\n\n\n\n```http\n\nPUT /collections/{collection_name}\n\n{\n\n    ""vectors"": {\n\n        ""size"": 300,\n\n        ""distance"": ""Cosine""\n\n    },\n\n    ""shard_number"": 6,\n\n    ""replication_factor"": 2,\n\n    ""write_consistency_factor"": 2,\n\n}\n\n```\n\n\n\n```python,source:documentation/guides/distributed_deployment.md'
 'document:- `write_consistency_factor` - defines the number of replicas that must acknowledge a write operation before responding to the client. Increasing this value will make write operations tolerant to network partitions in the cluster, but will require a higher number of replicas to be active to perform write operations.,source:documentation/guides/distributed_deployment.md']","The `write_consistency_factor` parameter in a distributed deployment using Qdrant defines the number of replicas that must acknowledge a write operation before responding to the client. By increasing this value, the write operations become more tolerant to network partitions within the cluster. However, this also means that a higher number of replicas need to be active in order to perform write operations successfully."
